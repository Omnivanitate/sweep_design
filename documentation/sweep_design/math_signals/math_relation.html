<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sweep_design.math_signals.math_relation API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sweep_design.math_signals.math_relation</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import logging
from typing import Tuple, Type, TypeVar, Union

import numpy as np
from numpy.typing import NDArray

from ..config import Config
from .defaults.base_structures import (
    BadInputError,
    MathOperation,
    NotEqualError,
    RelationProtocol,
    TypeFuncError,
)

Num = Union[float, int, complex]
R = TypeVar(&#34;R&#34;, bound=&#34;Relation&#34;)
R2 = TypeVar(&#34;R2&#34;, bound=&#34;Relation&#34;)


class Relation:
    &#34;&#34;&#34;A representation of dependency y from x (y = f(x))

    The class describe a dependency between two sequences x, y,
    represented by real or complex numbers. The length of sequences must be
    the same, and the sampling rate must not change throughout the entire
    sequence.

    **Properties**:
    &gt; **x**: `Union[RelationProtocol, NDArray]`
    The Relation class, or a class derived from the Relation class, or
    an array_like object containing numbers(real or complex).

    &gt; **y**: `NDArray` = None.
    None or array_like object containing real or complex numbers.

    &gt; **dx**: `float` = None.
    Sample rate x-axis.

    For the instance of `Relation` class, define the basic mathematical operstions:
    *additon (+), subtraction(-), multiplication(&#39;*&#39;), devision(/),
    expopnentiation (&#39;*&#39;&#39;*&#39;) and their unary representation (+=, -=, *=, /=).
    The result of the operation is a new instance of the Relation class.

    Determined correlation and convolution between two instances
    (methods: correlate and convolve).

    How those operations will be calculated determined by the methods described
    in the Config class. Methods can be overridden if necessary
    (sweep_design.math_signals.config).

    WARNING!!! When inheriting the Relation class, it is important to write correctly
    constructor. It must match the constructor of the Relation class.
    Because some methods return a type(self)(...). For example,
    addition method (def __add__(self: R, other: Union[&#39;Relation&#39;, Num])
     -&gt; R). Or predefine these methods in the inherited class.

    &#34;&#34;&#34;

    def __init__(
        self,
        x: Union[RelationProtocol, NDArray],
        y: NDArray = None,
        dx: float = None,
        **kwargs,
    ) -&gt; None:

        self._math_operation = Config.math_operation
        self._interpolate_extrapolate_method = Config.interpolate_extrapolate_method
        self._integrate_one_method = Config.integrate_one_method
        self._integrate_method = Config.integrate_method
        self._differentiate_method = Config.differentiate_method

        self._dx = dx

        if isinstance(x, RelationProtocol):
            self._x, self._y = x.get_data()
            if y is not None:
                logging.warning(f&#39;x is instance of {type(x)}, &#34;y&#34; was ignored&#39;)
        else:
            if y is None:
                raise BadInputError(&#34;y absent. Not enough data!&#34;)

            if Config.CONVERT2ARRAY:
                x, y = np.array(x), np.array(y)

            if x.size != y.size:
                raise NotEqualError(x.size, y.size)

            self._x, self._y = x, y

    @property
    def x(self) -&gt; np.ndarray:
        return self._x.copy()

    @property
    def dx(self) -&gt; float:
        if self._dx is not None:
            return self._dx
        diff_x = np.diff(self._x)
        values, counts = np.unique(diff_x, return_counts=True)

        num = values[np.argmax(counts)]
        if num &lt; 1:
            self._dx = 1 / round(1 / num)
        else:
            self._dx = round(num)
        return self._dx

    @dx.setter
    def dx(self, value: float) -&gt; None:
        self._dx = value

    @property
    def y(self) -&gt; np.ndarray:
        return self._y.copy()

    def get_data(self) -&gt; Tuple[np.ndarray, np.ndarray]:
        &#34;&#34;&#34;Return the data of the called object.&#34;&#34;&#34;
        return self._x.copy(), self._y.copy()

    def max(self) -&gt; Num:
        return self._y.max()

    def min(self) -&gt; Num:
        return self._y.min()

    def get_norm(self) -&gt; float:
        &#34;&#34;&#34;Get signal rate.

        Calculated in terms of signal energy.
        &#34;&#34;&#34;
        x, y = self._x, self._y
        return self._integrate_one_method(y**2, x) / (self.dx)

    def select_data(self: R, x_start: Num = None, x_end: Num = None, **kwargs) -&gt; R:
        &#34;&#34;&#34;Select data using x-axis.&#34;&#34;&#34;

        x, y = self.get_data()

        if x_start is None:
            x_start = x[0]

        if x_end is None:
            x_end = x[-1]

        is_selected = np.logical_and(
            np.greater_equal(self._x, x_start), np.less_equal(self._x, x_end)
        )

        return type(self)(x[is_selected], y[is_selected], **kwargs)

    def exp(self: R, **kwargs) -&gt; R:
        x, y = self.get_data()
        return type(self)(x, np.exp(y), **kwargs)

    def diff(self: R, **kwargs) -&gt; R:
        x, y = self.get_data()
        result = self._differentiate_method(x, y, self.dx)
        return type(self)(*result, **kwargs)

    def integrate(self: R, **kwargs) -&gt; R:
        x, y = self.get_data()
        result = self._integrate_method(x, y, self.dx)
        return type(self)(*result, **kwargs)

    def interpolate_extrapolate(self: R, new_x: np.ndarray, **kwargs) -&gt; R:
        new_y = self._interpolate_extrapolate_method(self._x, self._y)(new_x)
        return type(self)(new_x, new_y, **kwargs)

    def shift(self: R, x_shift: Num = 0, **kwargs) -&gt; R:
        x, y = self.get_data()
        return type(self)(x + x_shift, y, **kwargs)

    @staticmethod
    def equalize(r1: R, r2: R2) -&gt; Tuple[R, R2]:
        x1, _ = r1.get_data()
        x2, _ = r2.get_data()
        comparation = x1 == x2
        if isinstance(comparation, np.ndarray):
            if all(comparation):
                return r1, r2
        x_new = Config.get_common_x(x1, x2, r1.dx, r2.dx)
        r1 = r1.interpolate_extrapolate(x_new)
        r2 = r2.interpolate_extrapolate(x_new)
        return r1, r2

    @classmethod
    def correlate(cls: Type[R], r1: &#34;Relation&#34;, r2: &#34;Relation&#34;, **kwargs) -&gt; R:

        if isinstance(r1, Relation) and isinstance(r2, Relation):
            result = Config.correlate_method(cls, r1, r2)
            return cls(*result, **kwargs)
        else:
            raise TypeFuncError(&#34;Correlation&#34;, type(r1), type(r2))

    @classmethod
    def convolve(cls: Type[R], r1: &#34;Relation&#34;, r2: &#34;Relation&#34;, **kwargs) -&gt; R:

        if isinstance(r1, Relation) and isinstance(r2, Relation):
            result = Config.convolve_method(cls, r1, r2)
            return cls(*result, **kwargs)
        else:
            raise TypeFuncError(&#34;Convolution&#34;, type(r1), type(r2))

    @staticmethod
    def _operation(
        a: &#34;Relation&#34;, b: Union[&#34;Relation&#34;, Num], name_operation: MathOperation
    ) -&gt; Tuple[np.ndarray, np.ndarray]:
        logging.debug(f&#34;Type of a: {type(a)}&#34;)
        logging.debug(f&#34;Type of b: {type(b)}&#34;)
        if isinstance(b, RelationProtocol):
            r1, r2 = Relation.equalize(a, b)
            x, y1 = r1.get_data()
            _, y2 = r2.get_data()
            return a._math_operation(x, y1, y2, name_operation)
        elif isinstance(b, (float, int, complex)):
            x, y = a.get_data()
            return a._math_operation(x, y, b, name_operation)
        else:
            raise TypeFuncError(name_operation.value.strip(&#34;_&#34;), type(a), type(b))

    def __add__(self: R, other: Union[&#34;Relation&#34;, Num], **kwargs) -&gt; R:
        return type(self)(*self._operation(self, other, MathOperation.ADD), **kwargs)

    def __radd__(self: R, other: Union[&#34;Relation&#34;, Num], **kwargs) -&gt; R:
        return type(self)(*self._operation(self, other, MathOperation.RADD), **kwargs)

    def __sub__(self: R, other: Union[&#34;Relation&#34;, Num], **kwargs) -&gt; R:
        return type(self)(*self._operation(self, other, MathOperation.SUB), **kwargs)

    def __rsub__(self: R, other: Union[&#34;Relation&#34;, Num], **kwargs) -&gt; R:
        return type(self)(*self._operation(self, other, MathOperation.RSUB), **kwargs)

    def __mul__(self: R, other: Union[&#34;Relation&#34;, Num], **kwargs) -&gt; R:
        return type(self)(*self._operation(self, other, MathOperation.MUL), **kwargs)

    def __rmul__(self: R, other: Union[&#34;Relation&#34;, Num], **kwargs) -&gt; R:
        return type(self)(*self._operation(self, other, MathOperation.RMUL), **kwargs)

    def __truediv__(self: R, other: Union[&#34;Relation&#34;, Num], **kwargs) -&gt; R:
        return type(self)(
            *self._operation(self, other, MathOperation.TRUEDIV), **kwargs
        )

    def __rtruediv__(self: R, other: Union[&#34;Relation&#34;, Num], **kwargs) -&gt; R:
        return type(self)(
            *self._operation(self, other, MathOperation.RTRUEDIV), **kwargs
        )

    def __pow__(self: R, other: Union[&#34;Relation&#34;, Num], **kwargs) -&gt; R:
        return type(self)(*self._operation(self, other, MathOperation.POW), **kwargs)

    def __rpow__(self: R, other: Union[&#34;Relation&#34;, Num], **kwargs) -&gt; R:
        return type(self)(*self._operation(self, other, MathOperation.RPOW), **kwargs)

    def __iadd__(self: R, other: Union[&#34;Relation&#34;, Num], **kwargs) -&gt; R:
        return self.__add__(other, **kwargs)

    def __isub__(self: R, other: Union[&#34;Relation&#34;, Num], **kwargs) -&gt; R:
        return self.__sub__(other, **kwargs)

    def __imul__(self: R, other: Union[&#34;Relation&#34;, Num], **kwargs) -&gt; R:
        return self.__mul__(other, **kwargs)

    def __idiv__(self: R, other: Union[&#34;Relation&#34;, Num], **kwargs) -&gt; R:
        return self.__truediv__(other, **kwargs)

    def __ipow__(self: R, other: Union[&#34;Relation&#34;, Num], **kwargs) -&gt; R:
        return self.__pow__(other, **kwargs)

    def __len__(self) -&gt; int:
        return self._x.size

    def __getitem__(self, item: Union[float, slice]):
        if isinstance(item, float):
            idx = (np.abs(self._x - item)).argmin()
            return self._x[idx], self._y[idx]
        if isinstance(item, slice):
            return self.select_data(item.start, item.stop)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sweep_design.math_signals.math_relation.Relation"><code class="flex name class">
<span>class <span class="ident">Relation</span></span>
<span>(</span><span>x: Union[<a title="sweep_design.math_signals.defaults.base_structures.RelationProtocol" href="defaults/base_structures.html#sweep_design.math_signals.defaults.base_structures.RelationProtocol">RelationProtocol</a>, numpy.ndarray[Any, numpy.dtype[+ScalarType]]], y: numpy.ndarray = None, dx: float = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A representation of dependency y from x (y = f(x))</p>
<p>The class describe a dependency between two sequences x, y,
represented by real or complex numbers. The length of sequences must be
the same, and the sampling rate must not change throughout the entire
sequence.</p>
<p><strong>Properties</strong>:</p>
<blockquote>
<p><strong>x</strong>: <code>Union[RelationProtocol, NDArray]</code>
The Relation class, or a class derived from the Relation class, or
an array_like object containing numbers(real or complex).</p>
<p><strong>y</strong>: <code>NDArray</code> = None.
None or array_like object containing real or complex numbers.</p>
<p><strong>dx</strong>: <code>float</code> = None.
Sample rate x-axis.</p>
</blockquote>
<p>For the instance of <code><a title="sweep_design.math_signals.math_relation.Relation" href="#sweep_design.math_signals.math_relation.Relation">Relation</a></code> class, define the basic mathematical operstions:
<em>additon (+), subtraction(-), multiplication('</em>'), devision(/),
expopnentiation ('<em>''</em>') and their unary representation (+=, -=, *=, /=).
The result of the operation is a new instance of the Relation class.</p>
<p>Determined correlation and convolution between two instances
(methods: correlate and convolve).</p>
<p>How those operations will be calculated determined by the methods described
in the Config class. Methods can be overridden if necessary
(sweep_design.math_signals.config).</p>
<p>WARNING!!! When inheriting the Relation class, it is important to write correctly
constructor. It must match the constructor of the Relation class.
Because some methods return a type(self)(&hellip;). For example,
addition method (def <strong>add</strong>(self: R, other: Union['Relation', Num])
-&gt; R). Or predefine these methods in the inherited class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Relation:
    &#34;&#34;&#34;A representation of dependency y from x (y = f(x))

    The class describe a dependency between two sequences x, y,
    represented by real or complex numbers. The length of sequences must be
    the same, and the sampling rate must not change throughout the entire
    sequence.

    **Properties**:
    &gt; **x**: `Union[RelationProtocol, NDArray]`
    The Relation class, or a class derived from the Relation class, or
    an array_like object containing numbers(real or complex).

    &gt; **y**: `NDArray` = None.
    None or array_like object containing real or complex numbers.

    &gt; **dx**: `float` = None.
    Sample rate x-axis.

    For the instance of `Relation` class, define the basic mathematical operstions:
    *additon (+), subtraction(-), multiplication(&#39;*&#39;), devision(/),
    expopnentiation (&#39;*&#39;&#39;*&#39;) and their unary representation (+=, -=, *=, /=).
    The result of the operation is a new instance of the Relation class.

    Determined correlation and convolution between two instances
    (methods: correlate and convolve).

    How those operations will be calculated determined by the methods described
    in the Config class. Methods can be overridden if necessary
    (sweep_design.math_signals.config).

    WARNING!!! When inheriting the Relation class, it is important to write correctly
    constructor. It must match the constructor of the Relation class.
    Because some methods return a type(self)(...). For example,
    addition method (def __add__(self: R, other: Union[&#39;Relation&#39;, Num])
     -&gt; R). Or predefine these methods in the inherited class.

    &#34;&#34;&#34;

    def __init__(
        self,
        x: Union[RelationProtocol, NDArray],
        y: NDArray = None,
        dx: float = None,
        **kwargs,
    ) -&gt; None:

        self._math_operation = Config.math_operation
        self._interpolate_extrapolate_method = Config.interpolate_extrapolate_method
        self._integrate_one_method = Config.integrate_one_method
        self._integrate_method = Config.integrate_method
        self._differentiate_method = Config.differentiate_method

        self._dx = dx

        if isinstance(x, RelationProtocol):
            self._x, self._y = x.get_data()
            if y is not None:
                logging.warning(f&#39;x is instance of {type(x)}, &#34;y&#34; was ignored&#39;)
        else:
            if y is None:
                raise BadInputError(&#34;y absent. Not enough data!&#34;)

            if Config.CONVERT2ARRAY:
                x, y = np.array(x), np.array(y)

            if x.size != y.size:
                raise NotEqualError(x.size, y.size)

            self._x, self._y = x, y

    @property
    def x(self) -&gt; np.ndarray:
        return self._x.copy()

    @property
    def dx(self) -&gt; float:
        if self._dx is not None:
            return self._dx
        diff_x = np.diff(self._x)
        values, counts = np.unique(diff_x, return_counts=True)

        num = values[np.argmax(counts)]
        if num &lt; 1:
            self._dx = 1 / round(1 / num)
        else:
            self._dx = round(num)
        return self._dx

    @dx.setter
    def dx(self, value: float) -&gt; None:
        self._dx = value

    @property
    def y(self) -&gt; np.ndarray:
        return self._y.copy()

    def get_data(self) -&gt; Tuple[np.ndarray, np.ndarray]:
        &#34;&#34;&#34;Return the data of the called object.&#34;&#34;&#34;
        return self._x.copy(), self._y.copy()

    def max(self) -&gt; Num:
        return self._y.max()

    def min(self) -&gt; Num:
        return self._y.min()

    def get_norm(self) -&gt; float:
        &#34;&#34;&#34;Get signal rate.

        Calculated in terms of signal energy.
        &#34;&#34;&#34;
        x, y = self._x, self._y
        return self._integrate_one_method(y**2, x) / (self.dx)

    def select_data(self: R, x_start: Num = None, x_end: Num = None, **kwargs) -&gt; R:
        &#34;&#34;&#34;Select data using x-axis.&#34;&#34;&#34;

        x, y = self.get_data()

        if x_start is None:
            x_start = x[0]

        if x_end is None:
            x_end = x[-1]

        is_selected = np.logical_and(
            np.greater_equal(self._x, x_start), np.less_equal(self._x, x_end)
        )

        return type(self)(x[is_selected], y[is_selected], **kwargs)

    def exp(self: R, **kwargs) -&gt; R:
        x, y = self.get_data()
        return type(self)(x, np.exp(y), **kwargs)

    def diff(self: R, **kwargs) -&gt; R:
        x, y = self.get_data()
        result = self._differentiate_method(x, y, self.dx)
        return type(self)(*result, **kwargs)

    def integrate(self: R, **kwargs) -&gt; R:
        x, y = self.get_data()
        result = self._integrate_method(x, y, self.dx)
        return type(self)(*result, **kwargs)

    def interpolate_extrapolate(self: R, new_x: np.ndarray, **kwargs) -&gt; R:
        new_y = self._interpolate_extrapolate_method(self._x, self._y)(new_x)
        return type(self)(new_x, new_y, **kwargs)

    def shift(self: R, x_shift: Num = 0, **kwargs) -&gt; R:
        x, y = self.get_data()
        return type(self)(x + x_shift, y, **kwargs)

    @staticmethod
    def equalize(r1: R, r2: R2) -&gt; Tuple[R, R2]:
        x1, _ = r1.get_data()
        x2, _ = r2.get_data()
        comparation = x1 == x2
        if isinstance(comparation, np.ndarray):
            if all(comparation):
                return r1, r2
        x_new = Config.get_common_x(x1, x2, r1.dx, r2.dx)
        r1 = r1.interpolate_extrapolate(x_new)
        r2 = r2.interpolate_extrapolate(x_new)
        return r1, r2

    @classmethod
    def correlate(cls: Type[R], r1: &#34;Relation&#34;, r2: &#34;Relation&#34;, **kwargs) -&gt; R:

        if isinstance(r1, Relation) and isinstance(r2, Relation):
            result = Config.correlate_method(cls, r1, r2)
            return cls(*result, **kwargs)
        else:
            raise TypeFuncError(&#34;Correlation&#34;, type(r1), type(r2))

    @classmethod
    def convolve(cls: Type[R], r1: &#34;Relation&#34;, r2: &#34;Relation&#34;, **kwargs) -&gt; R:

        if isinstance(r1, Relation) and isinstance(r2, Relation):
            result = Config.convolve_method(cls, r1, r2)
            return cls(*result, **kwargs)
        else:
            raise TypeFuncError(&#34;Convolution&#34;, type(r1), type(r2))

    @staticmethod
    def _operation(
        a: &#34;Relation&#34;, b: Union[&#34;Relation&#34;, Num], name_operation: MathOperation
    ) -&gt; Tuple[np.ndarray, np.ndarray]:
        logging.debug(f&#34;Type of a: {type(a)}&#34;)
        logging.debug(f&#34;Type of b: {type(b)}&#34;)
        if isinstance(b, RelationProtocol):
            r1, r2 = Relation.equalize(a, b)
            x, y1 = r1.get_data()
            _, y2 = r2.get_data()
            return a._math_operation(x, y1, y2, name_operation)
        elif isinstance(b, (float, int, complex)):
            x, y = a.get_data()
            return a._math_operation(x, y, b, name_operation)
        else:
            raise TypeFuncError(name_operation.value.strip(&#34;_&#34;), type(a), type(b))

    def __add__(self: R, other: Union[&#34;Relation&#34;, Num], **kwargs) -&gt; R:
        return type(self)(*self._operation(self, other, MathOperation.ADD), **kwargs)

    def __radd__(self: R, other: Union[&#34;Relation&#34;, Num], **kwargs) -&gt; R:
        return type(self)(*self._operation(self, other, MathOperation.RADD), **kwargs)

    def __sub__(self: R, other: Union[&#34;Relation&#34;, Num], **kwargs) -&gt; R:
        return type(self)(*self._operation(self, other, MathOperation.SUB), **kwargs)

    def __rsub__(self: R, other: Union[&#34;Relation&#34;, Num], **kwargs) -&gt; R:
        return type(self)(*self._operation(self, other, MathOperation.RSUB), **kwargs)

    def __mul__(self: R, other: Union[&#34;Relation&#34;, Num], **kwargs) -&gt; R:
        return type(self)(*self._operation(self, other, MathOperation.MUL), **kwargs)

    def __rmul__(self: R, other: Union[&#34;Relation&#34;, Num], **kwargs) -&gt; R:
        return type(self)(*self._operation(self, other, MathOperation.RMUL), **kwargs)

    def __truediv__(self: R, other: Union[&#34;Relation&#34;, Num], **kwargs) -&gt; R:
        return type(self)(
            *self._operation(self, other, MathOperation.TRUEDIV), **kwargs
        )

    def __rtruediv__(self: R, other: Union[&#34;Relation&#34;, Num], **kwargs) -&gt; R:
        return type(self)(
            *self._operation(self, other, MathOperation.RTRUEDIV), **kwargs
        )

    def __pow__(self: R, other: Union[&#34;Relation&#34;, Num], **kwargs) -&gt; R:
        return type(self)(*self._operation(self, other, MathOperation.POW), **kwargs)

    def __rpow__(self: R, other: Union[&#34;Relation&#34;, Num], **kwargs) -&gt; R:
        return type(self)(*self._operation(self, other, MathOperation.RPOW), **kwargs)

    def __iadd__(self: R, other: Union[&#34;Relation&#34;, Num], **kwargs) -&gt; R:
        return self.__add__(other, **kwargs)

    def __isub__(self: R, other: Union[&#34;Relation&#34;, Num], **kwargs) -&gt; R:
        return self.__sub__(other, **kwargs)

    def __imul__(self: R, other: Union[&#34;Relation&#34;, Num], **kwargs) -&gt; R:
        return self.__mul__(other, **kwargs)

    def __idiv__(self: R, other: Union[&#34;Relation&#34;, Num], **kwargs) -&gt; R:
        return self.__truediv__(other, **kwargs)

    def __ipow__(self: R, other: Union[&#34;Relation&#34;, Num], **kwargs) -&gt; R:
        return self.__pow__(other, **kwargs)

    def __len__(self) -&gt; int:
        return self._x.size

    def __getitem__(self, item: Union[float, slice]):
        if isinstance(item, float):
            idx = (np.abs(self._x - item)).argmin()
            return self._x[idx], self._y[idx]
        if isinstance(item, slice):
            return self.select_data(item.start, item.stop)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sweep_design.math_signals.math_signal.Signal" href="math_signal.html#sweep_design.math_signals.math_signal.Signal">Signal</a></li>
<li><a title="sweep_design.math_signals.math_signal.Spectrum" href="math_signal.html#sweep_design.math_signals.math_signal.Spectrum">Spectrum</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sweep_design.math_signals.math_relation.Relation.convolve"><code class="name flex">
<span>def <span class="ident">convolve</span></span>(<span>r1: <a title="sweep_design.math_signals.math_relation.Relation" href="#sweep_design.math_signals.math_relation.Relation">Relation</a>, r2: <a title="sweep_design.math_signals.math_relation.Relation" href="#sweep_design.math_signals.math_relation.Relation">Relation</a>, **kwargs) ‑> ~R</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def convolve(cls: Type[R], r1: &#34;Relation&#34;, r2: &#34;Relation&#34;, **kwargs) -&gt; R:

    if isinstance(r1, Relation) and isinstance(r2, Relation):
        result = Config.convolve_method(cls, r1, r2)
        return cls(*result, **kwargs)
    else:
        raise TypeFuncError(&#34;Convolution&#34;, type(r1), type(r2))</code></pre>
</details>
</dd>
<dt id="sweep_design.math_signals.math_relation.Relation.correlate"><code class="name flex">
<span>def <span class="ident">correlate</span></span>(<span>r1: <a title="sweep_design.math_signals.math_relation.Relation" href="#sweep_design.math_signals.math_relation.Relation">Relation</a>, r2: <a title="sweep_design.math_signals.math_relation.Relation" href="#sweep_design.math_signals.math_relation.Relation">Relation</a>, **kwargs) ‑> ~R</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def correlate(cls: Type[R], r1: &#34;Relation&#34;, r2: &#34;Relation&#34;, **kwargs) -&gt; R:

    if isinstance(r1, Relation) and isinstance(r2, Relation):
        result = Config.correlate_method(cls, r1, r2)
        return cls(*result, **kwargs)
    else:
        raise TypeFuncError(&#34;Correlation&#34;, type(r1), type(r2))</code></pre>
</details>
</dd>
<dt id="sweep_design.math_signals.math_relation.Relation.equalize"><code class="name flex">
<span>def <span class="ident">equalize</span></span>(<span>r1: ~R, r2: ~R2) ‑> Tuple[~R, ~R2]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def equalize(r1: R, r2: R2) -&gt; Tuple[R, R2]:
    x1, _ = r1.get_data()
    x2, _ = r2.get_data()
    comparation = x1 == x2
    if isinstance(comparation, np.ndarray):
        if all(comparation):
            return r1, r2
    x_new = Config.get_common_x(x1, x2, r1.dx, r2.dx)
    r1 = r1.interpolate_extrapolate(x_new)
    r2 = r2.interpolate_extrapolate(x_new)
    return r1, r2</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="sweep_design.math_signals.math_relation.Relation.dx"><code class="name">var <span class="ident">dx</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dx(self) -&gt; float:
    if self._dx is not None:
        return self._dx
    diff_x = np.diff(self._x)
    values, counts = np.unique(diff_x, return_counts=True)

    num = values[np.argmax(counts)]
    if num &lt; 1:
        self._dx = 1 / round(1 / num)
    else:
        self._dx = round(num)
    return self._dx</code></pre>
</details>
</dd>
<dt id="sweep_design.math_signals.math_relation.Relation.x"><code class="name">var <span class="ident">x</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def x(self) -&gt; np.ndarray:
    return self._x.copy()</code></pre>
</details>
</dd>
<dt id="sweep_design.math_signals.math_relation.Relation.y"><code class="name">var <span class="ident">y</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def y(self) -&gt; np.ndarray:
    return self._y.copy()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sweep_design.math_signals.math_relation.Relation.diff"><code class="name flex">
<span>def <span class="ident">diff</span></span>(<span>self: ~R, **kwargs) ‑> ~R</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diff(self: R, **kwargs) -&gt; R:
    x, y = self.get_data()
    result = self._differentiate_method(x, y, self.dx)
    return type(self)(*result, **kwargs)</code></pre>
</details>
</dd>
<dt id="sweep_design.math_signals.math_relation.Relation.exp"><code class="name flex">
<span>def <span class="ident">exp</span></span>(<span>self: ~R, **kwargs) ‑> ~R</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exp(self: R, **kwargs) -&gt; R:
    x, y = self.get_data()
    return type(self)(x, np.exp(y), **kwargs)</code></pre>
</details>
</dd>
<dt id="sweep_design.math_signals.math_relation.Relation.get_data"><code class="name flex">
<span>def <span class="ident">get_data</span></span>(<span>self) ‑> Tuple[numpy.ndarray, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the data of the called object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data(self) -&gt; Tuple[np.ndarray, np.ndarray]:
    &#34;&#34;&#34;Return the data of the called object.&#34;&#34;&#34;
    return self._x.copy(), self._y.copy()</code></pre>
</details>
</dd>
<dt id="sweep_design.math_signals.math_relation.Relation.get_norm"><code class="name flex">
<span>def <span class="ident">get_norm</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Get signal rate.</p>
<p>Calculated in terms of signal energy.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_norm(self) -&gt; float:
    &#34;&#34;&#34;Get signal rate.

    Calculated in terms of signal energy.
    &#34;&#34;&#34;
    x, y = self._x, self._y
    return self._integrate_one_method(y**2, x) / (self.dx)</code></pre>
</details>
</dd>
<dt id="sweep_design.math_signals.math_relation.Relation.integrate"><code class="name flex">
<span>def <span class="ident">integrate</span></span>(<span>self: ~R, **kwargs) ‑> ~R</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def integrate(self: R, **kwargs) -&gt; R:
    x, y = self.get_data()
    result = self._integrate_method(x, y, self.dx)
    return type(self)(*result, **kwargs)</code></pre>
</details>
</dd>
<dt id="sweep_design.math_signals.math_relation.Relation.interpolate_extrapolate"><code class="name flex">
<span>def <span class="ident">interpolate_extrapolate</span></span>(<span>self: ~R, new_x: numpy.ndarray, **kwargs) ‑> ~R</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate_extrapolate(self: R, new_x: np.ndarray, **kwargs) -&gt; R:
    new_y = self._interpolate_extrapolate_method(self._x, self._y)(new_x)
    return type(self)(new_x, new_y, **kwargs)</code></pre>
</details>
</dd>
<dt id="sweep_design.math_signals.math_relation.Relation.max"><code class="name flex">
<span>def <span class="ident">max</span></span>(<span>self) ‑> Union[float, int, complex]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def max(self) -&gt; Num:
    return self._y.max()</code></pre>
</details>
</dd>
<dt id="sweep_design.math_signals.math_relation.Relation.min"><code class="name flex">
<span>def <span class="ident">min</span></span>(<span>self) ‑> Union[float, int, complex]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def min(self) -&gt; Num:
    return self._y.min()</code></pre>
</details>
</dd>
<dt id="sweep_design.math_signals.math_relation.Relation.select_data"><code class="name flex">
<span>def <span class="ident">select_data</span></span>(<span>self: ~R, x_start: Union[float, int, complex] = None, x_end: Union[float, int, complex] = None, **kwargs) ‑> ~R</span>
</code></dt>
<dd>
<div class="desc"><p>Select data using x-axis.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_data(self: R, x_start: Num = None, x_end: Num = None, **kwargs) -&gt; R:
    &#34;&#34;&#34;Select data using x-axis.&#34;&#34;&#34;

    x, y = self.get_data()

    if x_start is None:
        x_start = x[0]

    if x_end is None:
        x_end = x[-1]

    is_selected = np.logical_and(
        np.greater_equal(self._x, x_start), np.less_equal(self._x, x_end)
    )

    return type(self)(x[is_selected], y[is_selected], **kwargs)</code></pre>
</details>
</dd>
<dt id="sweep_design.math_signals.math_relation.Relation.shift"><code class="name flex">
<span>def <span class="ident">shift</span></span>(<span>self: ~R, x_shift: Union[float, int, complex] = 0, **kwargs) ‑> ~R</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shift(self: R, x_shift: Num = 0, **kwargs) -&gt; R:
    x, y = self.get_data()
    return type(self)(x + x_shift, y, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sweep_design.math_signals" href="index.html">sweep_design.math_signals</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sweep_design.math_signals.math_relation.Relation" href="#sweep_design.math_signals.math_relation.Relation">Relation</a></code></h4>
<ul class="">
<li><code><a title="sweep_design.math_signals.math_relation.Relation.convolve" href="#sweep_design.math_signals.math_relation.Relation.convolve">convolve</a></code></li>
<li><code><a title="sweep_design.math_signals.math_relation.Relation.correlate" href="#sweep_design.math_signals.math_relation.Relation.correlate">correlate</a></code></li>
<li><code><a title="sweep_design.math_signals.math_relation.Relation.diff" href="#sweep_design.math_signals.math_relation.Relation.diff">diff</a></code></li>
<li><code><a title="sweep_design.math_signals.math_relation.Relation.dx" href="#sweep_design.math_signals.math_relation.Relation.dx">dx</a></code></li>
<li><code><a title="sweep_design.math_signals.math_relation.Relation.equalize" href="#sweep_design.math_signals.math_relation.Relation.equalize">equalize</a></code></li>
<li><code><a title="sweep_design.math_signals.math_relation.Relation.exp" href="#sweep_design.math_signals.math_relation.Relation.exp">exp</a></code></li>
<li><code><a title="sweep_design.math_signals.math_relation.Relation.get_data" href="#sweep_design.math_signals.math_relation.Relation.get_data">get_data</a></code></li>
<li><code><a title="sweep_design.math_signals.math_relation.Relation.get_norm" href="#sweep_design.math_signals.math_relation.Relation.get_norm">get_norm</a></code></li>
<li><code><a title="sweep_design.math_signals.math_relation.Relation.integrate" href="#sweep_design.math_signals.math_relation.Relation.integrate">integrate</a></code></li>
<li><code><a title="sweep_design.math_signals.math_relation.Relation.interpolate_extrapolate" href="#sweep_design.math_signals.math_relation.Relation.interpolate_extrapolate">interpolate_extrapolate</a></code></li>
<li><code><a title="sweep_design.math_signals.math_relation.Relation.max" href="#sweep_design.math_signals.math_relation.Relation.max">max</a></code></li>
<li><code><a title="sweep_design.math_signals.math_relation.Relation.min" href="#sweep_design.math_signals.math_relation.Relation.min">min</a></code></li>
<li><code><a title="sweep_design.math_signals.math_relation.Relation.select_data" href="#sweep_design.math_signals.math_relation.Relation.select_data">select_data</a></code></li>
<li><code><a title="sweep_design.math_signals.math_relation.Relation.shift" href="#sweep_design.math_signals.math_relation.Relation.shift">shift</a></code></li>
<li><code><a title="sweep_design.math_signals.math_relation.Relation.x" href="#sweep_design.math_signals.math_relation.Relation.x">x</a></code></li>
<li><code><a title="sweep_design.math_signals.math_relation.Relation.y" href="#sweep_design.math_signals.math_relation.Relation.y">y</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>